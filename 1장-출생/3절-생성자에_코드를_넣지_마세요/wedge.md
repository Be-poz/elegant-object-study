# 생성자엔 할당 이외에 다른 코드는 없어야 한다.
- 필요한 경우에 인자를 다른 타입의 객체로 감싸거나 row-from으로 캡슐화하여 사용하여야 한다.

- 다음은 Number를 프로퍼티로 가지는 Cash 객체에 String을 통해 생성하려고 할 때의 예제이다. parseInt를 통해 파싱하여 바로 할당하고 싶겠지만 다음 방식처럼 실행코드는 lazy하게 만들어야한다.
```java
class Cash{
  private Number dollars;
  
  Cash(String dlr){
    this(new StringAsInteger(dlr));
  }
  Cash(Number dlr){
    this.dollars = dlr;
  }
  
}

class StringAsInteger implements Number{
  private String source;
  
  StringAsInteger(String src){
    this.source = src;
  }
  
  int intValue(){
    return Integer.parseInt(this.source);
  }
}
``` 

- 언뜻 생각하기에 생성자에서 한번만 해줬으면 될 parse를 여러번 하게 될테니, 성능상 문제가 생길 것 같지만 저자의 생각은 다르다.
- build만 해주고 파싱 등의 로직은 **요청이 있을 때 (on demand)** 해줌으로써, 되려 성능 최적화를 할 수 있다.

# 느낀 점
- 성능이란건, 시점이 중요한 것 같다. 이 글을 읽기전까지의 관점은 `모든 게 완벽한 상황에서 행위가 몇번 일어나는가` 로 성능을 가늠했다.
- (물리학에선 가정을 할 때 `진공 상태에 있는 완벽한 구형의 물체`를 많이 활용한다고 한다 ㅋㅋㅋ 하지만 실제세계에 그런 케이스는 존재하지 않는다. 비슷한 느낌인듯?)
- 하지만 만약 해당 객체가 실제론 활용되지 않는다면 그런 최적화가 무슨 소용일까? 성능 최적화의 여지가 없다는 저자의 말에 동의한다.
- 또, 한번만 했어도 될 파싱이 여러 번 일어났다고 해도, 해당 행위가 일어난 시점이 언제인가? 도 중요하다고 느꼈다.
 한번 파싱의 비용이 1, 여러번 파싱의 비용이 5라고 가정해보자. 
 다른 객체들이 활발하게 활동하여 프로세서가 현재 처리해야 할 작업량이 99라고 한다면 이 객체가 `한번만` 파싱해서 발생하는 1의 작업량도 부담일 것이다.
 이 객체만 활동하여 프로세서가 널널한(null null한 아님) 상황이라면 `여러번` 파싱의 비용도 부담이 아닐 것이다.
 즉 행위가 발생하는 시점 또한 성능에서 중요한 요소 일거라는 깨달음..
 
- 그러나 시점까지 고려하여 성능 최적화를 한다는건 프로그램의 복잡성을 무시하는 처사일 것이다. 모든 상황을 예측할 수는 없다. 그러므로 무조건 최적화를 시켜놔야겠지만.. 시점도 생각해볼만한 주제라고 생각한다. 
